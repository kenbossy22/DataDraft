<!DOCTYPE html>
<html>
<head>
  <title>3D Scatterplot in VR</title>
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@4.0.0/dist/aframe-physics-system.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/super-hands"></script>
</head>
<body>
  <a-scene>
    <!-- Sky -->
    <a-sky color="#000" radius="50"></a-sky>

    <!-- Axes -->
    <a-entity>
      <a-box position="5 0 0" width="10" height="0.05" depth="0.05" color="red"></a-box>
      <a-text value="Completeness Rating" position="10.5 0.2 0" rotation="0 0 0" color="red"></a-text>

      <a-box position="0 5 0" width="0.05" height="10" depth="0.05" color="green"></a-box>
      <a-text value="PtPG" position="0 10.5 0.2" rotation="0 0 0" color="green"></a-text>

      <a-box position="0 0 5" width="0.05" height="0.05" depth="10" color="blue"></a-box>
      <a-text value="Weighted Rating" position="0.2 0 10.5" rotation="0 0 0" color="blue"></a-text>
    </a-entity>

    <!-- Data Points -->
    <a-entity id="scatterplot" position="0 0 0" grab hoverable super-hands></a-entity>

    <!-- Camera -->
    <a-camera position="0 5 20" wasd-controls="enabled: true" look-controls="enabled: false">
      <a-cursor></a-cursor>
    </a-camera>

    <!-- Right Controller with Laser -->
    <a-entity id="right-controller" laser-controls="hand: right" raycaster="objects: .hoverable">
      <a-sphere position="0 0 -0.05" radius="0.02" color="white"></a-sphere>
    </a-entity>
  </a-scene>

  <script>
    fetch('scatter_data.json')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok ' + response.statusText);
        }
        return response.json();
      })
      .then(data => {
        const scatterplot = document.getElementById('scatterplot');
        let lastHovered = null; // To track the last hovered sphere

        data.forEach(point => {
          const { 'Completeness Rating': x, 'Weighted_Rating': z, 'PtPG': y, 'Player Name': name, Games, G, A, Pts, PPP, ShotsPG, HitsPG, BlocksPG } = point;

          // Adjust the scale for better visualization
          const scaledX = x / 10;
          const scaledY = y * 5;
          const scaledZ = z / 10;

          // Create datapoint sphere
          const sphere = document.createElement('a-sphere');
          sphere.setAttribute('position', `${scaledX} ${scaledY} ${scaledZ}`);
          sphere.setAttribute('radius', 0.2);
          sphere.setAttribute('color', getColorFromMetric(y));
          sphere.setAttribute('class', 'hoverable'); // Make it raycastable
          scatterplot.appendChild(sphere);

          // Create tooltip for the datapoint
          const tooltip = document.createElement('a-text');
          tooltip.setAttribute('value', 
            `Player: ${name}
Completeness Rating: ${x.toFixed(1)}
Weighted Rating: ${z.toFixed(1)}
Points per Game (PtPG): ${y.toFixed(1)}
Games: ${Games}
Goals: ${G}
Assists: ${A}
Points: ${Pts}
Powerplay Points: ${PPP}
Shots per Game: ${ShotsPG}
Hits per Game: ${HitsPG}
Blocks per Game: ${BlocksPG}`
          );

          // Position the tooltip slightly to the side of the sphere
          tooltip.setAttribute('position', `0.5 0 0`); // Adjust X for horizontal offset
          tooltip.setAttribute('align', 'left'); // Align text to the left
          tooltip.setAttribute('scale', '0.5 0.5 0.5');
          tooltip.setAttribute('color', 'yellow');
          tooltip.setAttribute('visible', false);
          sphere.appendChild(tooltip);

          // Show tooltip and hide others dynamically
          sphere.addEventListener('mouseenter', () => {
            if (lastHovered && lastHovered !== sphere) {
              lastHovered.children[0].setAttribute('visible', false); // Hide the previous tooltip
            }
            tooltip.setAttribute('visible', true);
            lastHovered = sphere; // Set the current sphere as the last hovered
          });

          sphere.addEventListener('mouseleave', () => {
            tooltip.setAttribute('visible', false);
            lastHovered = null; // Reset when leaving
          });
        });
      })
      .catch(error => {
        console.error('Error loading scatterplot data:', error);
      });

    // Function to get color based on Points per Game
    function getColorFromMetric(ptpg) {
      if (ptpg < 0.75) return 'blue';
      if (ptpg <= 1.0) return 'yellow';
      return 'green';
    }

    // Combine left joystick movement and right joystick camera rotation
    document.addEventListener('gamepadconnected', () => {
      const camera = document.querySelector('a-camera').object3D;

      const updateControls = () => {
        const gamepads = navigator.getGamepads();
        const gp = gamepads[0]; // Assuming Oculus controller is the first gamepad

        if (gp) {
          // Left joystick: Movement
          const moveX = gp.axes[0] * 0.2; // Left joystick horizontal (left/right)
          const moveZ = gp.axes[1] * 0.2; // Left joystick vertical (forward/backward)
          camera.position.x -= moveX;
          camera.position.z += moveZ;

          // Right joystick: Rotation
          const rotateY = gp.axes[2] * 0.05; // Right joystick horizontal (yaw)
          const rotateX = gp.axes[3] * 0.05; // Right joystick vertical (pitch)
          camera.rotation.y -= rotateY; // Rotate camera horizontally
          camera.rotation.x -= rotateX; // Rotate camera vertically

          camera.rotation.x = Math.max(Math.min(camera.rotation.x, Math.PI / 2), -Math.PI / 2); // Clamp vertical rotation
        }

        requestAnimationFrame(updateControls);
      };

      updateControls();
    });

    // Add interaction logic for laser pointer
    document.querySelector('#right-controller').addEventListener('raycaster-intersection', (evt) => {
      const [intersectedEl] = evt.detail.intersectedEls; // Closest intersected element
      if (intersectedEl && intersectedEl.classList.contains('hoverable')) {
        intersectedEl.children[0].setAttribute('visible', true); // Show tooltip
      }
    });
    document.querySelector('#right-controller').addEventListener('raycaster-intersection-cleared', (evt) => {
      const [intersectedEl] = evt.detail.clearedEls;
      if (intersectedEl && intersectedEl.classList.contains('hoverable')) {
        intersectedEl.children[0].setAttribute('visible', false); // Hide tooltip
      }
    });
  </script>
</body>
</html>
